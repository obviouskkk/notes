## 假设移动操作是不存在的、不廉价的、不能用的

### 什么时候编译器会为生成移动构造函数
#### 显式支持移动操作
- 注意：为了确保C++98旧代码依赖的保证不会因程序提升到C++11而被打破，只有当移动操作不抛异常时，才会把内部的拷贝当作替换成移动操作。即使一个类提供移动操作，这个移动操作相对拷贝操作高效很多，即使在代码的某个位置，移动操作是合适的（例如，源对象是个右值），编译器可能仍然会使用拷贝操作，因为它对应的移动操作没有声明为noexcept。
#### 编译器为你生成默认的
首先，它和拷贝构造函数的地位是相同的，有些情况是会为你免费生成的
- 没有声明拷贝操作、移动操作、析构函数，
- 成员变量或者基类的移动构造函数被delete

### STL的移动操作
- C++所有的容器都支持移动操作
- 对于一些容器，移动它们的内容真心不廉价；而对于另外的容器，它们提供的廉价移动操作在元素不满足条件时会发出警告。

#### 一些不适合移动的容器
- `std::array`  
移动和拷贝一个std::array都需要线性时间的计算复杂度，因为容器中的每个元素都需要被移动或拷贝
- `std::string`  
提供常量时间的移动和线性时间的拷贝,但是，许多string的实现都使用了small string optimization(SSO)，通过SSO，“small”string（例如，那些容量不超过15字符的string）会被存储到std::string对象内的一个缓冲区中；不需要使用堆分配的策略。移动一个基于SSO实现的small string不比拷贝它快，因为一般的移动操作拷贝单个指针的把戏在这里不适用。  
SSO存在的动机是：有大量证据表明在大多数应用中普遍使用短字符串。使用内部缓冲区存储string的内容可以消除动态分配内存的需求，而这通常赢得效率。但是，这个实现移动不比拷贝快，也可以反过来说，对于这种string，拷贝不比移动慢。
- 异常  

### 结论
- 假设移动操作是不存在的、不廉价的、不能用的。
- 在知道类型或支持移动语义的代码中，不需要这个假设。
对已知类型可以放心大胆的去移动，对于template，小心谨慎。


## Effective Modern C++ 条款30 熟悉完美转发失败的情况
转发的意思是一个函数传递——转发——它的参数到另一个函数，目的是为了让第二个函数（被转发参数的函数）收到第一个函数（进行转发的函数）接受到的对象。
完美转发意思是：我们不单单转发对象，我们还转发它们重要的特性：它们的类型，它们是右值还是左值，它们是否是const或者volation修饰的。
### 几种不能完美转发的类型
完美转发失败的几种原因：  （参数由fwd传递给f）
- 编译器不能推断出传递给fwd参数的类型，在这种情况下，代码编译失败。
- 编译器为传递给fwd参数推断出“错误的”类型。这里的“错误的”，可以表示实例化的fwd不能编译推断出来的类型，还可以表示使用fwd推断的类型调用f的行为与直接使用传递给fwd的参数调用f的行为不一致。这种不一致行为的一种源头是f是个重载函数的名字，然后，根据“不正确的”推断类型，fwd里的f重载调用与直接调用f的行为不一样。
#### 大括号初始值
也是一种C++11支持的初始化方式：
```
void f(const std::vector<int>& v);
f({1, 2, 3});   // 正确，“{1，2，3}”被隐式转换为std::vector<int>
fwd({1,2,3})；   // 错误，不能编译
```
没有声明为std::initialist_list类型的模板参数传递大括号初始值。编译器禁止从表达式{1,2,3}推断出一个类型，因为fwd的形参不是声明为std::initializer_list。因为那是被禁止推断，所以编译器拒绝这样调用。
正确的做法：
```
auto il = {1, 2, 3};               // il的类型被推断为std::initializer_list<int>
fwd(il);           // 正确，把il转发给f
```
#### 0和NULL作为空指针
条款8解释过，当你尝试把0和NULL作为空指针传递给一个模板，类型推断就会出错，编译器会把你传入的参数推断为整型数类型（通常是int），而不是指针类型。这就导致了0和NULL都不可以作为空指针被完美转发，不过，解决办法也很容易：用nullptr代替0或NULL。
#### 只声明的static const成员变量
不需要在类中定义static const成员变量；声明它就行了。那是因为编译器会为这些成员变量的值进行const propagation（常数传播）,因此不需要为这些变量提供内存。即多个对象，共用一份内存。
对于`static const std::size_t MinVals = 28;`是无法转发的。  
解决方案是：在类外重新定义，.cpp文件中即可：`const std::size_t Widget::MinVals;`
#### 重载函数名字和模板名字
名字一样很坑啊。 
#### 位域（Bitfields）
```
struct IPv4Header {
    std::uint32_t version : 4,
                  IHL : 4,
                  DSCP : 6,
                  ECN : 2,
                  totalLength : 16;
    ...
};
```
现在这个转发的时候，肯定出错啦：
```
void f(std::size_t sz);   // 被调用的函数

IPv4Header h;
...
fwd(h.totalLength);         // 错误
```
解决方案：
```
auto length = static_cast<std::uint16_t>(h.totalLength);
fwd(length);   // 转发拷贝
```

### 总结
- 当模板类型推断失败或推断出错误的类型时，完美转发会失败。
- 导致完美转发失败的几种实参有：大括号初始值，0和NULL代表的空指针，只声明的static const成员变量，模板函数名字和重载函数名字，位域。
