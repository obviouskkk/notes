---
title: 从重构看编程习惯
categories: c++
tags: 编程经验
---

## 背景

最近两周，应老大的要求完成这样一项工作：在一个巨大的C++项目里，有一个记录打点的功能的，需要接受http请求然后完成某项工作。事实上，接受请求后，根据类型字段判断走何种逻辑，打点功能和其他功能逻辑完全无关。我的任务就是把这部分逻辑从当前进程剥离出来，作为一个单独的服务。这里记录一下遇到的坑和一些不好的编码习惯。

## 如何快速模块拆分重组
我想我这次的工作并不能称之为重构，目的很明确：不修改逻辑，把模块独立出来。

### 一些编译错误
不得不说，大部分时间都在编译和修改编译错误。错误不多一般就几种：  
`has not been declared`：未定义，使用了没有包含头文件的函数，static变量没有在类外定义。
`undefined reference to`：找不到实现，大部分是给出了头文件而找不到实现。
`redefinition of...`：重定义了，编译器会提示那几处定义了，头文件里如果有定义，那么很容易出现这个问题，我这次没怎么遇到。
`no such file`：头文件找不到，我遇到了很多，因为有些头文件依赖很多东西，而我并不想包含它。  
事实证明，所有的编译问题都是容易解决的，除非它引入了太多你不想要的东西。
### 渐进编译
我的做法是：完全新建一个目录，写下main函数，然后照着之前的逻辑开始拷贝代码，如果它需要其他头文件，那么将头文件和实现拷过来，进行编译。假如有某个函数的实现和其他模块有太多的牵连，比如头文件里或者源文件里又包含了非常多的其他的头文件，会瞬间导致文件个数暴增，编译变得困难，那么我会选择注释掉这个函数，加上标记方便我回头找到它，用一个其他的值代替它，比如`if(afun()) --> if (true)`。当然你也可以在它的头文件和源文件中注释掉某些内容使其通过编译。
许多代码会像树一样，主流程就是主干，期间会调用许多函数，就像枝干一样，函数调用越深，枝干也就越细越长。我们要做的就是保证主流程每新加一点东西都能通过编译，当枝丫不容易通过编译时就先砍掉一部分。

### 使用工具保存的进度
git是个很适合的工具，你可以发现你改动了那些部分，当新加的内容能通过编译后，别犹豫`commit`，并写上详细的信息。

### 拆分文件
工作越往后进行我越发现我加入编译的文件越来越多，小而美才是我想要的。我在这里发现了很多奇怪的文件，名字都包含`...common...`，里面有非常之多的函数，写了一个函数没地方放就放到`common`w文件里？
我的做法是，头文件里的函数全部保留，但是头文件基本全部注释掉或者改用前置声明。源文件里的函数基本全注释掉，然后编译。编译器会告诉我那些文件我没有定义，这时候把它取消掉注释就好了。

### 工具
公司用的scons，用不太习惯，我选择了Cmake，很幸运。这个项目所有依赖的库基本都在项目目录下，跟机器关系不大，cmake不需要写find_lib。源文件不要指定整个目录，一个一个的源文件加进去，修改起来非常方便。

## 编程习惯
折腾了差不多两个周，看了好多代码，不多不说写代码的都是大牛，同时呢，一些问题可能大家常说但是没体会到它的危害，我这次算是深刻体会到了。

### 命名空间
命名空间应该是C++对于C最大的几个亮点之一了。公司前辈们当然也很懂，很多代码都写在了命名空间内。但是一句`using namespace ...`,全毁了。嗯，改成了`A::B::xxx`，瞬间心旷神怡。

### 太长的头文件
`common`头文件和源文件都是典型的长文件。洋洋洒洒近万行的代码，100多行的`include`简直是一种灾难。相比这个，我想我更喜欢短小、命名准确的文件，哪怕文件数目很多。

### 成员函数和非成员函数
因为项目是处理http请求的，所以有很多从文本解析数据的函数，然后我差不多在每个文件里都看见了处理函数，名字都相差不远。显然，一个类需要从文本中获取数据，所以这个方法就写在了类自身，这样的方法太多就造成可读性极差。更好的方法显然是：将从文本获取数据的方法集中起来，甚至它们不用组合成一个类，只需要把它们放在一个命名空间里就好。

### 长函数和调用过深
这样的代码读起来真的很困难啊。

